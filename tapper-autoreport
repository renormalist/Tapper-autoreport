#! /bin/bash

# ====================================================================
#
# tapper-autoreport
# -----------------
#
# This is the "tapper-autoreport" bash utility -- a bash include file
# that you include ("source") at the end of your own bash script.
#
# It then magically turns your bash script into a Tapper test suite.
#
# It collects meta information from system, reports test results via
# network and uploads files.
#
# It also allows your bash script to be used with the "prove" command,
# a tool to run test scripts that produce TAP output (Test Anything
# Protocol).
#
# It is licensed under a 2-clause BSD license. See the LICENSE file.
#
# ====================================================================


# ==================== Utility functions =============================

# gets vendor "AMD" or "Intel" from /proc/cpuinfo
get_vendor () {
    vendor=$(echo $(grep vendor_id /proc/cpuinfo |head -1|cut -d: -f2|sed -e "s/Genuine\|Authentic//"))
    echo $vendor
}

# checks for vendor "Intel" in /proc/cpuinfo
vendor_intel () {
    grep -Eq 'vendor_id.*:.*Intel' /proc/cpuinfo
}

# checks for vendor "AMD" in /proc/cpuinfo
vendor_amd () {
    grep -Eq 'vendor_id.*:.*AMD' /proc/cpuinfo
}

# stops testscript if not matching required cpu vendor
require_vendor_intel () {
    if vendor_intel
    then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_vendor_intel" ; fi
        return 0
    else
        explanation="${1:-vendor does not match Intel}"
        autoreport_skip_all "$explanation"
    fi
}

# stops testscript if not matching required cpu vendor
require_vendor_amd () {
    if vendor_amd
    then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_vendor_amd" ; fi
        return 0
    else
        explanation="${1:-vendor does not match AMD}"
        autoreport_skip_all "$explanation"
    fi
}

# Checks for ARM cpu
arm_cpu () {
    grep -Eqi 'Processor.*:.*ARM' /proc/cpuinfo
}

# outputs cpu family from /proc/cpuinfo
# since all testsuites using hex values, return value in hex format
get_cpu_family () {
    fam=$(echo $(grep family /proc/cpuinfo |head -1|cut -d: -f2))
    echo "0x"$(get_hex_from_int $fam)
}

# checks cpu family from /proc/cpuinfo against a minimum family
cpu_family_min () {
    min=${1:-0}
    fam=$(get_cpu_family)
    [ $(($fam)) -ge $(($min)) ]
}

# checks cpu family from /proc/cpuinfo against a maximum family
cpu_family_max () {
    max=${1:-0x999}
    fam=$(get_cpu_family)
    [ $(($fam)) -le $(($max)) ]
}

# stops testscript if not matching required cpu family from
# /proc/cpuinfo of a minimum/maximum range
require_amd_family_range () {
    min="${1:-0}"
    max="${2:-$min}"
    if vendor_amd && cpu_family_min "$min" && cpu_family_max "$max" ;
    then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_amd_family_range $min $max" ; fi
        return 0
    else
        vendor=$(get_vendor);
        fam=$(get_cpu_family);
        explanation="${3:-Family $vendor/$fam does not match AMD/$min..$max}"
        autoreport_skip_all "$explanation"
    fi
}

# check sysfs whether cpu has L3 cache
has_l3cache () {
    if [ -d /sys/devices/system/cpu/cpu0/cache/index3 ] ; then
        return 0
    else
        return 1
    fi
}

# stops testscript if cpu does not have L3 cache
require_l3cache () {
    explanation="${1:-No L3 cache}"
    if has_l3cache ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_l3cache" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# check if we are in a Xen guest
# Note:
#   In Xen the dom0 reports the same 'hypervisor' flag and CPUID entry
#   as in domU therefore the CPUID check is not enough, but dmidecode
#   and lspci show different devices inside a domU.
is_running_in_xen_guest () {
    SUCC=1

    # try dmidecode
    if dmidecode > /dev/null 2>&1 ; then
        dmidecode -s chassis-manufacturer | grep -q Xen
        SUCC=$?
    else
        # try lspci
        if lspci > /dev/null 2>&1 ; then
            lspci | grep -q Xen
            SUCC=$?
        fi
    fi
    return $SUCC
}


# check if we are in a KVM guest
# Note:
#   In KVM the hypervisor CPUID check is relieable and we can first
#   narrow it against being not a Xen guest. After that the devices
#   are less significant in KVM so here we then check for the CPUID.
is_running_in_kvm_guest () {
    SUCC=1

    # try dmidecode
    if grep -Eqi "^flags.*:.*hypervisor" /proc/cpuinfo ; then
        if ! is_running_in_xen_guest ; then
            if modprobe cpuid > /dev/null 2>&1 ; then
                CPUID=$(dd if=/dev/cpu/0/cpuid bs=16 skip=67108864 count=1 status=noxfer 2> /dev/null)
                if echo $CPUID | grep -q KVM ; then
                    SUCC=0
                fi
            fi
        fi
    fi
    return $SUCC
}

# check for Tapper automation guest environment
is_running_in_tapper_guest () {
    SUCC=1
    if [ -n "$TAPPER_GUESTNUMBER" ] ; then
        if [ $TAPPER_GUESTNUMBER -gt 0 ] ; then
            SUCC=0
        fi
    fi
    return $SUCC
}

# check if we are in a virtualized guest (Xen or KVM)
# Note:
#   We could combine the _tapper_guest checking in here but I wanted
#   to keep the "real detection" separated from the "artificial
#   definition" that TAPPER_* environment variables represent.
is_running_in_virtualized_guest () {
    is_running_in_xen_guest || is_running_in_kvm_guest
    return $?
}

# stops testscript if we aren't a Xen guest
require_running_in_xen_guest () {
    explanation="${1:-Needs to run in Xen guest}"
    if is_running_in_xen_guest ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_running_in_xen_guest" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# stops testscript if we aren't a KVM guest
require_running_in_kvm_guest () {
    explanation="${1:-Needs to run in KVM guest}"
    if is_running_in_kvm_guest ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_running_in_kvm_guest" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# stops testscript if we aren't a virtualized guest
require_running_in_virtualized_guest () {
    explanation="${1:-Needs to run in virtualized guest}"
    if is_running_in_virtualized_guest ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_running_in_virtualized_guest" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# stops testscript if we aren't a Tapper automation guest environment
require_running_in_tapper_guest () {
    explanation="${1:-Needs to run in Tapper guest}"
    if is_running_in_tapper_guest ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_running_in_tapper_guest" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# checks for a feature flag in /proc/cpuinfo
has_cpufeature () {
    feature="${1:-UNKNOWNFEATURE}"
    if cat /proc/cpuinfo | grep -E '^flags\W*:' | head -1 | grep -q "\<${feature}\>" 2>&1 ; then
        return 0
    else
        return 1
    fi
}

# stops testscript if a feature flag is not found in /proc/cpuinfo
require_cpufeature () {
    feature="${1:-UNKNOWNFEATURE}"
    explanation="${2:-Missing cpufeature $feature}"
    if has_cpufeature "$feature" ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_cpufeature $feature" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# checks for a config in /proc/config.gz or /boot/config/$(uname -r)
has_kernel_config () {
    feature="${1:-UNKNOWNFEATURE}"
    CONFIG=$(get_first_file "/proc/config.gz" "/boot/config-$(uname -r)")
    if echo $CONFIG | grep -q '\.gz' ; then
        echo GZIPPED
        TEMP=${TEMP:-/tmp}
        tempfile="$TEMP/$$-tapper-autoreport-tempfile-$$.tmp"
        gunzip < $CONFIG > $tempfile
        CONFIG=$tempfile
    fi
    grep -q "^${feature}=." $CONFIG
    SUCC=$?
    if [ -f $tempfile ] ; then rm -f -- "$tempfile" ; fi
    return $SUCC
}

# stops testscript if a feature flag is not found in /proc/cpuinfo
require_kernel_config () {
    feature="${1:-UNKNOWNFEATURE}"
    explanation="${2:-Missing kernel config $feature}"
    if has_kernel_config "$feature" ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_kernel_config $feature" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# checks whether the cpbdisable file exists in sysfs
has_cpbdisable () {
    # This file's existence is not the best check.
    # It also exists on non-cpb systems.
    if [ -e /sys/devices/system/cpu/cpu0/cpufreq/cpb ] ; then
        return 0
    else
        return 1
    fi
}

# stops testscript if the cpbdisable file does not exist in sysfs
require_cpbdisable () {
    explanation="${1:-No CPB disable}"
    if has_cpbdisable ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_cpbdisable" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# checks whether the program is available
has_program () {
    program="${1:-UNKNOWNPROGRAM}"
    if which "$program" > /dev/null 2>&1 ; then
        return 0
    else
        return 1
    fi
}

# stops testscript if program not available
require_program () {
    program="${1:-UNKNOWNPROGRAM}"
    explanation="${2:-Missing program $program}"
    if has_program "$program" ; then
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

# stops testscript if netcat not available
require_netcat () {
    explanation="${2:-Missing program netcat}"
    if has_program "netcat" ; then
        return 0
    elif has_program "nc" ; then
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

require_root () {
    explanation="${1:-Need to run as root}"
    ID=$(id|cut -d" " -f1|cut -d= -f2|cut -d\( -f1)
    if [ "x$ID" == "x0" ] ; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_root" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

get_first_file () {
    for i in $(seq 1 $#) ; do
        file=${!i}
        if [ -r "$file" ] ; then
            echo "$file"
            return
        fi
    done
}

autoreport_skip_all () {
    explanation="${1:-'no explanation'}"
    SKIPALL="1..0 # skip $explanation"
    NOUPLOAD=1
}

# ==================== TAP utils ====================

get_tap_counter () {
     echo ${#TAP[@]}
}

get_tapdata_counter () {
     echo ${#TAPDATA[@]}
}

append_tap () {
    tapline="${1:-'not ok - unknown TAP line in utility function append_tap'}"
    TAP=( "${TAP[@]}" "$tapline" )
}

append_tapdata () {
    tapline="${1:-'not ok - unknown TAP line in utility function append_tapdata'}"
    TAPDATA=( "${TAPDATA[@]}" "$tapline" )
}

append_comment () {
    tapline="# ${1:-''}"
    TAP=( "${TAP[@]}" "$tapline" )
    COMMENTCOUNTER=$((COMMENTCOUNTER + 1))
}

ok () {
    success="${1:-0}"
    msg="${2:-unknown}"
    if [ "$success" != "0" ] ; then
        NOT="not "
    else
        NOT=""
    fi
    append_tap "${NOT}ok - $msg"
}

negate_ok () {
    success="${1:-0}"
    msg="${2:-unknown}"
    if [ "$success" == "0" ] ; then
        NOT="not "
    else
        NOT=""
    fi
    append_tap "${NOT}ok - $msg"
}

get_hex_from_int() { # returns lower case
    echo $(echo "obase=16; $1" | bc| tr '[A-Z]' '[a-z]')
}

lower_case () {
    string="${1:-}"
    echo $(echo "$string" | tr '[A-Z]' '[a-z]')
}

get_random_number () {
    range_max="${1:-32768}"
    number=$RANDOM
    let "number %= $range_max"
    echo "$number"
}

get_kernel_release_1 () {
    number=$(uname -r | sed 's/\([0-9]\)\.[0-9]\+\.[0-9]\+.*/\1/')
    echo "$number"
}

get_kernel_release_2 () {
    number=$(uname -r | sed 's/[0-9]\.\([0-9]\+\)\.[0-9]\+.*/\1/')
    echo "$number"
}

get_kernel_release_3 () {
    number=$(uname -r | sed 's/[0-9]\.[0-9]\+\.\([0-9]\+\).*/\1/')
    echo "$number"
}

has_kernel_release_min_1 () {
    # check if current LK 1st level release number is greater or equal release_req
    release_req="${1:-}"
    [ "$release_req" -ne $(echo $release_req|sed 's/^\([0-9]\+\).*/\1/') ] && return 1
    [ $(get_kernel_release_1) -ge "$release_req" ] && return 0
    return 1
}

has_kernel_release_min_2 () {
    # check if current LK 1st level release number is greater or equal release_req
    release_req="${1:-}"
    [ "$release_req" -ne $(echo $release_req|sed 's/^\([0-9]\+\).*/\1/') ] && return 1
    [ $(get_kernel_release_2) -ge "$release_req" ] && return 0
    return 1
}

has_kernel_release_min_3 () {
    # check if current LK 1st level release number is greater or equal release_req
    release_req="${1:-}"
    [ "$release_req" -ne $(echo $release_req|sed 's/^\([0-9]\+\).*/\1/') ] && return 1
    [ $(get_kernel_release_2) -ge "$release_req" ] && return 0
    return 1
}

require_kernel_release_min_1 () {
    # exit 0 if current LK release is less than required 3rd level version number
    release_req="${1:-}"
    explanation="${2:-Linux Kernel must be newer than ${release_req}.x.x}"
    if has_kernel_release_min_1 "$release_req"; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_kernel_release_min_1 $release_req" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

require_kernel_release_min_2 () {
    # exit 0 if current LK release is less than required 2nd level version number
    release_req="${1:-}"
    explanation="${2:-Linux Kernel must be newer than x.${release_req}.x}"
    if has_kernel_release_min_2 "$release_req"; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_kernel_release_min_2 $release_req" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

require_kernel_release_min_3 () {
    # exit 0 if current LK release is less than required 3rd level version number
    release_req="${1:-}"
    explanation="${2:-Linux Kernel must be newer than x.x-${release_req}}"
    if has_kernel_release_min_3 "$release_req"; then
        if [ "x1" = "x$REQUIRES_GENERATE_TAP" ] ; then ok 0 "require_kernel_release_min_3 $release_req" ; fi
        return 0
    else
        autoreport_skip_all "$explanation"
    fi
}

is_element_in_list () {
    # check if element is in list
    element="${1:-unknown}"
    list="${2:-unknown}"
    echo "$list"|egrep -q "\b$element\b"
    result=$?
    return $result
}

# ===== control variables defaults ==================

# by default require_* functions generate TAP ok lines
REQUIRES_GENERATE_TAP=${REQUIRES_GENERATE_TAP:-1}

# ===== kernel details ==================

kernelrelease=$(uname -r)

# ===== suite name ==================

SUITEKEYWORDS=$(for k in $KEYWORDS ; do echo $k ; done | sort | paste -sd-)
myname=$(echo $(basename -- $0 | sed -e 's/\.\w*$//i')${SUITEKEYWORDS:+-$SUITEKEYWORDS} | sed -e "s/^tapper-//" | sed -e "s/^artemis-//" )

SUITE=${myname:-autoreport}
VERSION=3.002

# ===== other meta info ==================

suite_name=${SUITENAME:-$(echo $SUITE)}
suite_version=${SUITEVERSION:-$VERSION}
hostname=${HOSTNAME:-$(hostname)}
# combined machine name in Tapper automation guest environment
if is_running_in_tapper_guest ; then
    if [ "x$TAPPER_HOSTNAME" != "x" ] ; then
        hostname="${TAPPER_HOSTNAME}:$hostname"
    fi
fi
reportername=${REPORTERNAME:-$USER}

if [ -e /etc/issue.net ]
then
	osname=${OSNAME:-$(cat /etc/issue.net | head -1)}
else
	osname=${OSNAME:-$(uname -o)}
fi

changeset=${CHANGESET:-$(cat /proc/version | head -1)}
kernelflags=$(cat /proc/cmdline)
uname=$(uname -a)
ram=$(free -m | grep -i mem: | awk '{print $2}'MB)
starttime_test_program=$(date --rfc-2822)
bogomips=$(echo $(cat /proc/cpuinfo | grep -i bogomips | head -1 | cut -d: -f2))
cpuinfo=$(
    if arm_cpu
    then
        cpu=$(grep 'Processor' < /proc/cpuinfo | cut -d: -f2- |head -1 | cut -d" " -f2);
    else
        cpu=$(grep 'model name' < /proc/cpuinfo | cut -d: -f2- | head -1 | sed -e "s/^ *//");
    fi
    cpucount=$(grep -i 'bogomips.*:' < /proc/cpuinfo | wc -l);
    echo "$cpucount cores [$cpu]";
)
# TODO: bogomips from /proc/cpuinfo

if [ -e "/boot/config-$kernelrelease" ]
then
	BOOTCONFIG="/boot/config-$kernelrelease"
else
	BOOTCONFIG=
fi
PROCCONFIG="/proc/config.gz"

ticketurl=${TICKETURL:-""}
wikiurl=${WIKIURL:-""}
planningid=${PLANNINGID:-""}
moreinfourl=${MOREINFOURL:-""}

# group reports with similar environment:
# - hostname
# - date
# - uname
# - cpuinfo
# - kernel config
reportgroup_testrun=${TAPPER_TESTRUN:-${ARTEMIS_TESTRUN:-}}
reportgroup=${REPORTGROUP:-$((echo $HOSTNAME ; date +%Y-%m-%d ; uname -a ; cat /proc/cpuinfo | grep -v MHz | grep -vi bogomips ; cat $(ls -1 $BOOTCONFIG $PROCCONFIG /dev/null 2> /dev/null | sort) ) | md5sum | cut -d" " -f1 )}

if [ ! "$reportgroup_testrun" ] ; then
    reportgroup_arbitrary=${TAPPER_REPORT_GROUP:-$reportgroup}
fi

tapper_suite_meta() {
    echo "# Tapper-suite-name:               $suite_name";
    echo "# Tapper-suite-version:            $suite_version";
    echo "# Tapper-machine-name:             $hostname";
    echo "# Tapper-reportername:             $reportername";

    if [ -n "$reportgroup_arbitrary" ] ; then
        echo "# Tapper-reportgroup-arbitrary:    $reportgroup_arbitrary";
    fi
    if [ -n "$reportgroup_testrun" ] ; then
        echo "# Tapper-reportgroup-testrun:      $reportgroup_testrun";
    fi
    if [ -n "$ticketurl" ] ; then
        echo "# Tapper-ticket-url:               $ticketurl";
    fi
    if [ -n "$wikiurl" ] ; then
        echo "# Tapper-wiki-url:                 $wikiurl";
    fi
    if [ -n "$planningid" ] ; then
        echo "# Tapper-planning-id:              $planningid";
    fi
    if [ -n "$moreinfourl" ] ; then
        echo "# Tapper-moreinfo-url:             $moreinfourl";
    fi
}

tapper_section_meta() {
    if [ ! "x1" = "x$DONTREPEATMETA" ] ; then
        echo "# Tapper-uname:                    $uname"
        echo "# Tapper-osname:                   $osname"
        echo "# Tapper-kernel:                   $kernelrelease"
        echo "# Tapper-changeset:                $changeset"
        echo "# Tapper-flags:                    $kernelflags"
        echo "# Tapper-cpuinfo:                  $cpuinfo"
        echo "# Tapper-ram:                      $ram"
        echo "# Tapper-starttime-test-program:   $starttime_test_program"
    fi

    if [ -n "$SECTION" ] ; then
        echo "# Tapper-section:              $SECTION"
    fi
}

tapper_help () {
    echo "tapper-autoreport"
    echo ""
    echo "For more info please see"
    echo "  https://github.com/amd/Tapper-autoreport/blob/master/autoreport-manual.md"
    echo ""
}

# =====================================================

# up to here functions are sourced by test scripts

[ "$1" == "--import-utils" ] && return 0
[ "$1" == "--help" ] && tapper_help && exit 0

# ===== param evaluation ==============================

if [ x"$HARNESS_ACTIVE" == x"1" ] ; then
    NOSEND=1
else
    require_netcat
fi

EXITCODE=0
OK=1
FILECOUNT=0

# do not implicitely upload files like kernel config
noupload=${NOUPLOAD:-0}

# extend that list with usernames that should magically be recognized
# as test owner when listing them as argument
KNOWNUSERS="root tapper"

KNOWNUSERS_REGEX=$(for k in $KNOWNUSERS ; do echo $k ; done | sort | paste -sd- | sed -e 's/-/\\|/g')

for i in $(seq 1 $#) ; do
    a=${!i}
    # echo "<${a}>"
    if echo "$a" | grep -Eq '^-?[0-9]+$' ; then
        if [ "$a" != "0" ] ; then
            EXITCODE=$a
        fi
    elif [ x"$a" == x"nok" ] ; then
        OK=0
    elif [ "x$a" == x"--version" ] ; then
        PRINTVERSION=1
    elif [ -e "$a" ] ; then
        FILES[$FILECOUNT]="$a"
        let FILECOUNT=FILECOUNT+1
    elif echo "$a" | grep -qi "^\\($KNOWNUSERS_REGEX\\)\$" ; then
        REPORTERNAME="$a"
    fi
done

# ===== kernel config files ==================

if [ ! "$NOUPLOAD" ] ; then
    if [ ! "x1" = "x$DONTREPEATMETA" ] ; then
        if [ -n "$BOOTCONFIG" ] ; then
            FILES[$FILECOUNT]="$BOOTCONFIG"
            let FILECOUNT=FILECOUNT+1
        fi
        if [ -e "$PROCCONFIG" ] ; then
            FILES[$FILECOUNT]="$PROCCONFIG"
            let FILECOUNT=FILECOUNT+1
        fi
    fi
fi

# ===== upload ourself ===============

if [ ! "x1" = "x$DONTREPEATMETA" ] ; then
    FILES[$FILECOUNT]="$0";            let FILECOUNT=FILECOUNT+1
fi

# ===== /proc files ==================

if [ ! "x1" = "x$DONTREPEATMETA" ] ; then
    FILES[$FILECOUNT]="/proc/cpuinfo"; let FILECOUNT=FILECOUNT+1
    FILES[$FILECOUNT]="/proc/devices"; let FILECOUNT=FILECOUNT+1
    FILES[$FILECOUNT]="/proc/version"; let FILECOUNT=FILECOUNT+1
fi

# ===== utility functions ==================

TAPPER_REPORT_SERVER=${TAPPER_REPORT_SERVER:-${ARTEMIS_REPORT_SERVER:-tapper}}
TAPPER_REPORT_PORT=${TAPPER_REPORT_PORT:-${ARTEMIS_REPORT_PORT:-7357}}
TAPPER_API_PORT=${TAPPER_API_PORT:-${ARTEMIS_API_PORT:-7358}}

prepare_plan() {
    # count of our own tests
    COUNT=${#TAP[@]}
    PLAN=$(($MYPLAN + $COUNT - $COMMENTCOUNTER))
}

upload_files() {
    MYNETCAT="$NETCAT $TAPPER_REPORT_SERVER $TAPPER_API_PORT"
    # echo "# Uploading:  $MYNETCAT ..." 1>&2
    for f in $(seq 0 $(($FILECOUNT - 1))) ; do
        file="${FILES[f]}"
        filetype=""
        if echo $file | grep -Eq '\.(gz|bz2)$' ; then
            filetype="application/octet-stream"
        fi
        echo -n "# - upload $file" 1>&2
        if [ "$filetype" ] ; then
            echo -n " ($filetype)" 1>&2
        fi
        echo " ..." 1>&2
        (
            echo "#! upload $reportid $file $filetype"
            cat $file
        ) | $MYNETCAT
    done
}

# ===== main =========================================

autoreport_main() {

    COMMENTCOUNTER=${COMMENTCOUNTER:-0}

    if [ -n "$SKIPALL" ] ; then
        echo "$SKIPALL"
        tapper_suite_meta
        tapper_section_meta
        export NOUPLOAD=1
        return
    fi

    # ==================== prepare plan

    # count of tests until "END of own tests"
    MYPLAN=4
    prepare_plan
    echo "TAP Version 13"
    echo "1..$PLAN"

    # ==================== meta info ====================
    tapper_suite_meta
    tapper_section_meta

    # =============== own headers (later entries win) ===============
    HEADERSCOUNT=${#HEADERS[@]}
    for l in $(seq 0 $(($HEADERSCOUNT - 1))) ; do
        echo ${HEADERS[l]}
    done

    # ,==================== BEGIN of own tests ====================
    # |
    #
    echo "ok - autoreport"

    # optionally provided exit code
    if [ x"$EXITCODE" != x"0" ] ; then echo -n "not " ; fi
    echo "ok - exitcode"
    if [ -n "$EXITCODE" ] ; then
        echo "  ---"
        echo "  exitcode: $EXITCODE"
        echo "  ..."
    fi

    # optionally provided "not ok"
    if [ x"$OK" = x"0" ] ; then echo -n "not " ; fi
    echo "ok - success"
    #
    # |
    # `==================== END of own tests ====================

    # ==================== remaining TAP ====================
    for l in $(seq 0 $(($COUNT - 1))) ; do
        echo ${TAP[l]}
    done

    # ==================== additional TAP/YAML data ====================
    echo "ok - tapdata"
    echo "  ---"
    echo "  tapdata: 1"
    TAPDATACOUNT=${#TAPDATA[@]}
    if [ "$TAPDATACOUNT" -gt 0 ] ; then
        for l in $(seq 0 $(($TAPDATACOUNT - 1))) ; do
            echo "  ${TAPDATA[l]}"
        done
    fi
    echo "  ..."

    # ==================== remaining output ====================
    OUTPUTCOUNT=${#OUTPUT[@]}
    for l in $(seq 0 $(($OUTPUTCOUNT - 1))) ; do
        echo ${OUTPUT[l]}
    done

    # ==================== files ====================
    for f in $(seq 0 $(($FILECOUNT - 1))) ; do
        echo "# File upload: '${FILES[f]}'"
    done

    if set | grep -q '^main_after_hook \(\)' ; then
        main_after_hook
    fi
}

# ===== main =========================================

autoreport_start () {

    if [ "$PRINTVERSION" ] ; then
        echo "$VERSION"
        exit 0
    fi

    if [ ! "x1" = "x$NOSEND" ] ; then
        NETCAT=$(which netcat || which nc)
        # does it provide -q option
        if $NETCAT -h 2>&1 |grep -q -- '-q.*quit' ; then
            NETCAT="$NETCAT -q7"
        fi
        NETCAT="$NETCAT -w7"
    else
        NETCAT=cat
    fi

    #echo "# NETCAT: $NETCAT"
    if [ -n "$TAPPER_REPORT_SERVER" ] ; then
        if [ ! "x1" = "x$NOSEND" ] ; then
            MYNETCAT="$NETCAT $TAPPER_REPORT_SERVER $TAPPER_REPORT_PORT"
            # echo    "# Reporting:  $MYNETCAT ..." 1>&2
            output=$( (autoreport_main | $MYNETCAT ; if [ "x1" = "x$NOSEND" ] ; then echo $NOSEND ; fi ) | tail -1 )
            reportid=$(echo $output | sed -e 's/^.*::Reports::Receiver. Protocol is TAP. Your report id: //')
            if [ ! "x1" = "x$NOSEND" ] ; then
                echo -n "# http://$TAPPER_REPORT_SERVER" 1>&2
                if echo $TAPPER_REPORT_SERVER | grep -q "bascha" ; then
                    echo -n ":3000"
                fi
                if echo $TAPPER_REPORT_SERVER | grep -q "artemis" ; then
                    echo "/artemis/reports/id/$reportid" 1>&2
                else
                    echo "/tapper/reports/id/$reportid" 1>&2
                fi
                upload_files
            fi
        else
            autoreport_main
        fi
    fi
}

autoreport_start
